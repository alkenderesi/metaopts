"""Population related utility functions."""

import tensorflow as tf
from .print import print_function_trace
from .fitness import update_population_fitness


def create_population(
        model_weights,
        population_size,
        transfer_learning=False,
        deviation=0.1
    ):
    """
    Creates a population of individuals (candidate solutions).

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        population_size: `int` - Number of individuals in the population.
        transfer_learning: `bool` - Whether to copy current model weights or generate random ones.
        deviation: `float` - Standard deviation of the normal distribution used to generate random weights.
    """

    if transfer_learning:

        # Return a population of individuals with the same weights as the model
        return [tf.Variable(tf.repeat([weights], population_size, axis=0)) for weights in model_weights]

    # Return a population of individuals with random weights
    return [tf.Variable(tf.random.normal((population_size,) + weights.shape, 0, deviation)) for weights in model_weights]


def sort_population(
        population,
        fitness_values
    ):
    """
    Sorts the population in ascending order based on fitness values.

    Args:
        population: `list` of `tf.Variable` - List of population weights.
        fitness_values: `tf.Variable` - Fitness values of the population.
    """

    # Print debug information
    print_function_trace('sort_population')

    # Sort fitness values in ascending order
    order = tf.argsort(fitness_values)

    # Assign new order to fitness values and the population
    fitness_values.assign(tf.gather(fitness_values, order, axis=0))
    for p in population:
        p.assign(tf.gather(p, order, axis=0))


def apply_best_solution(
        model_weights,
        model_fitness_fn,
        fitness_values,
        population,
        population_size
    ):
    """
    Applies the best solution of the population to the model.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        fitness_values: `tf.Variable` - Fitness values of the population.
        population: `list` of `tf.Variable` - List of population weights.
        population_size: `int` - Number of individuals in the population.
    """

    # Update fitness values
    update_population_fitness(
        model_weights,
        model_fitness_fn,
        fitness_values,
        population,
        population_size
    )

    # Best solution index
    best_solution_index = tf.argmin(fitness_values)

    # Apply best solution to the model
    for mw, p in zip(model_weights, population):
        mw.assign(p[best_solution_index])

    # Print debug information
    print('Best solution applied to model.')


sort_population = tf.function(sort_population)
